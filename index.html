<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SG Bus Arrival</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1D232A" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <link rel="icon" href="/bus.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
  <script src="https://unpkg.com/feather-icons"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@intelight/geolib@2.0.22/dist/geolib.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <style>
    .config-toggle {
      cursor: pointer;
    }
    .refresh-btn {
      cursor: pointer;
      font-size: 1.5em;
    }
    .spinner {
      font-size: 2em;
      margin: 20px auto;
      display: flex;
      justify-content: center;
    }
    .station-title {
      font-size: 1.2em;
    }
    .card-custom {
      background-color: var(--card-bg-color);
    }
    .autocomplete-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      background-color: var(--card-bg-color);
      border: 1px solid var(--border-color);
      max-height: 150px;
      overflow-y: auto;
      width: 100%;
      z-index: 10;
    }
    .autocomplete-suggestion {
      padding: 8px;
      cursor: pointer;
    }
    .autocomplete-suggestion:hover {
      background-color: var(--hover-bg-color);
    }
    /* Remove input border on focus and blur */
    .input:focus,
    .input:active {
      outline: none;
      box-shadow: none;
      border-color: transparent;
    }
    /* Remove input border */
    .input {
      border-color: transparent;
    }
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #1D232A; /* or your preferred color */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      font-size: 2em;
      overflow: hidden; /* Prevent scrolling */
      opacity: 0;
      animation: fadeIn 0.2s forwards, fadeOut 0.2s 1s forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    /* Add these new styles */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 480px;
      background-color: var(--card-bg-color);
      border-top: 1px solid var(--border-color);
      padding: 0.5rem;
      padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
      display: flex;
      justify-content: space-around;
      z-index: 50;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    /* Add a full-width background behind the nav */
    .bottom-nav::before {
      content: '';
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100%;
      background-color: var(--card-bg-color);
      z-index: -1;
    }

    .bottom-nav-item {
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      color: var(--text-color);
      text-decoration: none;
      font-size: 0.75rem;
      position: relative; /* For indicator */
      transition: all 0.2s ease;
      margin: 0 0.25rem;
      width: 100%;
      height: 100%;
      margin-top: 10px;
    }

    .bottom-nav-item.active {
      border-top: 5px solid;
      margin-top: 5px;
    }

    /* .bottom-nav-item.active i {
    } */

    /* Add smooth transition for icons */
    .bottom-nav-item i {
      transition: transform 0.2s ease;
    }

    .page-container {
      padding-bottom: calc(5rem + env(safe-area-inset-bottom));
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    .tab-page {
      height: calc(100vh - 5rem);
      padding: 1rem;
      overflow-y: auto;
      padding-bottom: calc(1rem + env(safe-area-inset-bottom));
      position: absolute;
      width: 100%;
      left: 0;
      opacity: 0;
      transform: translateX(100%);
      transition: transform 0.2s ease-out, opacity 0.2s ease-out;
      visibility: hidden;
      -webkit-overflow-scrolling: touch;
    }

    .tab-page.active {
      opacity: 1;
      transform: translateX(0);
      visibility: visible;
    }

    .tab-page.slide-left {
      transform: translateX(-100%);
    }

    .tab-page.slide-right {
      transform: translateX(100%);
    }

    .tab-page.previous {
      visibility: visible;
      opacity: 0;
    }

    /* Safe area padding for iOS - update these */
    @supports (padding: max(0px)) {
      .bottom-nav {
        padding-bottom: max(0.5rem, env(safe-area-inset-bottom));
      }
    }

    /* Add this to handle content scrolling */
    .tab-content {
      height: 100%;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }
  </style>
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  <link rel="preload" href="/stops.json" as="fetch" crossorigin>
  <link rel="preload" href="/services.json" as="fetch" crossorigin>
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
</head>
<body class="bg-base-100 min-h-screen flex flex-col">
  <div class="loading-screen" id="loading-screen">
    <i data-feather="heart" class="mr-2"></i> SG Bus Arrival
  </div>
  <div id="toast-container" class="toast toast-top toast-center"></div>

  <div class="mx-auto w-full max-w-[480px] relative">
    <div id="app"></div>
  </div>

  <script src="https://unpkg.com/preact@latest/dist/preact.min.js"></script>
  <script src="https://unpkg.com/preact@latest/hooks/dist/hooks.umd.js"></script>
  <script src="https://unpkg.com/htm@latest/dist/htm.umd.js"></script>


  <!-- Add this script before your main script -->
  <script>
    // Check for service worker and Push API support
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(function(swReg) {
          console.log('Service Worker is registered', swReg);
          window.swReg = swReg;
        })
        .catch(function(error) {
          console.error('Service Worker Error', error);
        });
    } else {
      console.log('Push messaging is not supported');
    }

    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function getPushSubscription(swReg) {
      try {
        // Fetch the public VAPID key from the server
        const response = await fetch('https://push.keva.dev/vapidPublicKey');
        const data = await response.json();
        const publicVapidKey = data.publicKey;
        
        // Request notification permission from the user
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
          console.log('Permission not granted for Notification, it is: ' + permission);
          throw new Error('Notification permission not granted');
        }
        
        // Subscribe to push notifications
        const subscription = await swReg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(publicVapidKey)
        });

        console.log('Push Subscription:', JSON.stringify(subscription));
        return subscription;
      } catch (error) {
        console.error('Error in initializePush:', error);
      }
    }

    // Hide the loading screen after 2 seconds
    window.addEventListener('load', () => {
      setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
          loadingScreen.style.display = 'none';
        }
      }, 1000);
    });
  </script>

  <script>
    const { h, render } = preact;
    const { useState, useEffect, useRef } = preactHooks;
    const html = htm.bind(h);

    function App() {
      const [isOffline, setIsOffline] = useState(!navigator.onLine);
      const [stationConfigs, setStationConfigs] = useState(() => {
        const savedConfigs = localStorage.getItem('stationConfigs');
        return savedConfigs ? JSON.parse(savedConfigs) : [
          { stationId: '10389', busNumbers: ['121', '122'] },
          { stationId: '10161', busNumbers: ['121', '122'] },
        ];
      });
      const [busArrivals, setBusArrivals] = useState({});
      const [error, setError] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [currentTime, setCurrentTime] = useState(Date.now());

      const [theme, setTheme] = useState(() => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) return savedTheme;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      });

      const [newStationInput, setNewStationInput] = useState('');
      const [newBusNumberInputs, setNewBusNumberInputs] = useState({});
      const [isConfigModalOpen, setIsConfigModalOpen] = useState(false);
      
      const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);

      const [rainForecast, setRainForecast] = useState(null);
      const [isRainLoading, setIsRainLoading] = useState(true);
      const [rainError, setRainError] = useState(null);

      const [stopsData, setStopsData] = useState({});
      const [stationSuggestions, setStationSuggestions] = useState([]);
      const [selectedStationId, setSelectedStationId] = useState(null);

      const [servicesData, setServicesData] = useState({});
      const [busNumberSuggestions, setBusNumberSuggestions] = useState({});
      const [stationToBusNumbers, setStationToBusNumbers] = useState({});

      const [isQRCodeModalOpen, setIsQRCodeModalOpen] = useState(false);
      const [exportURL, setExportURL] = useState('');

      const [userLocation, setUserLocation] = useState(null);
      const [locationRequested, setLocationRequested] = useState(false);

      const [activeTab, setActiveTab] = useState('home');
      const [previousTab, setPreviousTab] = useState(null);
      const [slideDirection, setSlideDirection] = useState(null);

      function toggleConfigModal() {
        setIsConfigModalOpen(!isConfigModalOpen);
      }
      
      function toggleInfoModal() {
        setIsInfoModalOpen(!isInfoModalOpen);
      }

      function addStation(e) {
        e.preventDefault();
        const stationId = selectedStationId || newStationInput.trim();
        if (stationId && !stationConfigs.find(s => s.stationId === stationId)) {
          const updatedConfigs = [...stationConfigs, { stationId: stationId, busNumbers: [] }];
          setStationConfigs(updatedConfigs);
          setNewStationInput('');
          setSelectedStationId(null);
          setStationSuggestions([]);
        }
      }

      function removeStation(stationId) {
        const updatedConfigs = stationConfigs.filter(s => s.stationId !== stationId);
        setStationConfigs(updatedConfigs);
        setNewBusNumberInputs(inputs => {
          const newInputs = { ...inputs };
          delete newInputs[stationId];
          return newInputs;
        });
        setBusNumberSuggestions(suggestions => {
          const newSuggestions = { ...suggestions };
          delete newSuggestions[stationId];
          return newSuggestions;
        });
      }

      function addBusNumber(e, stationId) {
        e.preventDefault();
        const newBusNumber = newBusNumberInputs[stationId];
        if (newBusNumber && newBusNumber.trim() !== '') {
          const updatedConfigs = stationConfigs.map(s => {
            if (s.stationId === stationId && !s.busNumbers.includes(newBusNumber)) {
              return { ...s, busNumbers: [...s.busNumbers, newBusNumber] };
            }
            return s;
          });
          setStationConfigs(updatedConfigs);
          setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: '' }));
          setBusNumberSuggestions(suggestions => ({ ...suggestions, [stationId]: [] }));
        }
      }

      function removeBusNumber(stationId, busNo) {
        const updatedConfigs = stationConfigs.map(s => {
          if (s.stationId === stationId) {
            return { ...s, busNumbers: s.busNumbers.filter(no => no !== busNo) };
          }
          return s;
        });
        setStationConfigs(updatedConfigs);
      }

      function handleBusNumberInputChange(stationId, value) {
        setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: value }));
        if (stationToBusNumbers[stationId]) {
          const suggestions = stationToBusNumbers[stationId]
            .filter(busNo => busNo.includes(value))
            .slice(0, 10);
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: suggestions }));
        } else {
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
        }
      }

      function handleBusNumberSelect(stationId, busNo) {
        setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: busNo }));
        setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
      }

      function handleBusNumberBlur(e, stationId) {
        // Hide suggestions after a short delay to allow clicks to register
        setTimeout(() => {
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
        }, 100);
      }

      function handleStationInputChange(value) {
        setNewStationInput(value);
        setSelectedStationId(null);

        if (value.length >= 2 && stopsData) {
          const suggestions = Object.keys(stopsData).map(stationId => {
            const stop = stopsData[stationId];
            return {
              stationId: stationId,
              name: stop[2],
              road: stop[3],
              displayName: `${stop[2]} (${stop[3]}) [${stationId}]`,
            };
          }).filter(stop => {
            const searchValue = value.toLowerCase();
            return stop.name.toLowerCase().includes(searchValue) || stop.stationId.includes(value);
          }).slice(0, 10);

          setStationSuggestions(suggestions);
        } else if (value.length === 0 && userLocation) {
          computeNearestStations(userLocation.latitude, userLocation.longitude);
        } else {
          setStationSuggestions([]);
        }
      }

      function handleStationSelect(suggestion) {
        setNewStationInput(suggestion.displayName);
        setSelectedStationId(suggestion.stationId);
        setStationSuggestions([]);
      }

      function handleStationInputFocus() {
        if (!locationRequested) {
          setLocationRequested(true);
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              position => {
                setUserLocation({
                  latitude: position.coords.latitude,
                  longitude: position.coords.longitude
                });
                computeNearestStations(position.coords.latitude, position.coords.longitude);
              },
              error => {
                console.error('Error getting location:', error);
                // Optionally, show a message or proceed without location
              },
              { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
          } else {
            console.error('Geolocation is not supported by this browser.');
            // Optionally, show a message or proceed without location
          }
        } else if (userLocation) {
          computeNearestStations(userLocation.latitude, userLocation.longitude);
        }
      }

      function handleStationInputBlur() {
        // Hide suggestions after a short delay to allow selection
        setTimeout(() => {
          setStationSuggestions([]);
        }, 100);
      }

      function computeNearestStations(latitude, longitude) {
        if (!stopsData) return;
        const stations = Object.keys(stopsData).map(stationId => {
          const stop = stopsData[stationId];
          const stopLat = stop[0];
          const stopLon = stop[1];
          const distance = geolib.getDistance(
            { latitude, longitude },
            { latitude: stopLat, longitude: stopLon }
          );
          return {
            stationId: stationId,
            name: stop[2],
            road: stop[3],
            displayName: `${stop[2]} (${stop[3]}) [${stationId}]`,
            distance: distance
          };
        });
        stations.sort((a, b) => a.distance - b.distance);
        const nearestStations = stations.slice(0, 5);
        setStationSuggestions(nearestStations);
      }

      function haversineDistance(lat1, lon1, lat2, lon2) {
        function toRad(x) {
          return x * Math.PI / 180;
        }

        const R = 6371; // Earth's radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const lat1Rad = toRad(lat1);
        const lat2Rad = toRad(lat2);

        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1Rad) * Math.cos(lat2Rad);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const d = R * c;
        return d; // distance in km
      }

      function getStationDisplayName(stationId) {
        if (stopsData && stopsData[stationId]) {
          const stop = stopsData[stationId];
          return `${stop[2]} (${stop[3]})`;
        }
        return 'Station ' + stationId;
      }

      function getBusArrivals() {
        // Change timeout to 5 seconds
        const fetchTimeout = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Fetch timeout')), 5000);
        });

        setIsLoading(true);
        let fetchPromises = stationConfigs.map(({ stationId, busNumbers }) => {
          return Promise.race([
            fetch(`https://arrivelah2.busrouter.sg/?id=${stationId}`),
            fetchTimeout
          ])
            .then(response => response.json())
            .then(data => {
              const buses = data.services;
              const targetBuses = buses.filter(bus => busNumbers.includes(bus.no));

              let arrivalTimes = [];

              targetBuses.forEach(bus => {
                ['next', 'subsequent', 'next2', 'next3'].forEach(key => {
                  if (bus[key] && bus[key].duration_ms !== null && bus[key].duration_ms >= 0) {
                    arrivalTimes.push({
                      busNo: bus.no,
                      arrivalTimestamp: Date.now() + bus[key].duration_ms,
                      stationId: stationId,
                      key: key
                    });
                  }
                });
              });

              // Remove duplicates
              arrivalTimes = arrivalTimes.filter((value, index, self) =>
                index === self.findIndex((t) => (
                  t.busNo === value.busNo && t.arrivalTimestamp === value.arrivalTimestamp
                ))
              );

              arrivalTimes.sort((a, b) => a.arrivalTimestamp - b.arrivalTimestamp);

              const soonestBuses = arrivalTimes.slice(0, 3);

              return { stationId: stationId, arrivals: soonestBuses };
            })
            .catch(error => {
              console.error(`Error fetching bus data for station ${stationId}:`, error);
              setError(`Error fetching bus data for station ${stationId}`);
              return { stationId: stationId, arrivals: [] };
            });
        });

        Promise.all(fetchPromises)
          .then(results => {
            let newBusArrivals = {};
            results.forEach(result => {
              newBusArrivals[result.stationId] = result.arrivals;
            });
            setBusArrivals(newBusArrivals);
          })
          .catch(error => {
            console.error('Error fetching bus arrivals:', error);
            setError('Failed to fetch bus arrivals');
            showToast('Failed to fetch bus arrivals. Retrying...', 'error');
            // Auto retry after 1 second
            setTimeout(() => {
              getBusArrivals();
            }, 1000);
          })
          .finally(() => {
            setIsLoading(false);
          });
      }

      function toggleTheme() {
        const newTheme = theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
        document.querySelector('html').setAttribute('data-theme', newTheme);

        // Update theme colors
        if (newTheme === 'light') {
          document.documentElement.style.setProperty('--card-bg-color', '#ffffff');
          document.documentElement.style.setProperty('--border-color', '#e5e7eb');
          document.documentElement.style.setProperty('--hover-bg-color', '#f3f4f6');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#ffffff');
          }
        } else {
          document.documentElement.style.setProperty('--card-bg-color', '#1f2937');
          document.documentElement.style.setProperty('--border-color', '#374151');
          document.documentElement.style.setProperty('--hover-bg-color', '#4b5563');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1D232A');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#1D232A');
          }
        }
      }

      useEffect(() => {
        function handleOnline() {
          setIsOffline(false);
          showToast('You are back online.', 'success');
        }

        function handleOffline() {
          setIsOffline(true);
          showToast('You are offline. Some features may not be available.', 'warning');
        }

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      useEffect(() => {
        localStorage.setItem('stationConfigs', JSON.stringify(stationConfigs));
      }, [stationConfigs]);

      useEffect(() => {
        document.querySelector('html').setAttribute('data-theme', theme);
        if (theme === 'light') {
          document.documentElement.style.setProperty('--card-bg-color', '#ffffff');
          document.documentElement.style.setProperty('--border-color', '#e5e7eb');
          document.documentElement.style.setProperty('--hover-bg-color', '#f3f4f6');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#ffffff');
          }
        } else {
          document.documentElement.style.setProperty('--card-bg-color', '#1f2937');
          document.documentElement.style.setProperty('--border-color', '#374151');
          document.documentElement.style.setProperty('--hover-bg-color', '#4b5563');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1D232A');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#1D232A');
          }
        }
      }, [theme]);

      useEffect(() => {
        getBusArrivals();

        const interval = setInterval(getBusArrivals, 30000);

        const timer = setInterval(() => {
          setCurrentTime(Date.now());
        }, 1000);

        fetchRainForecast();

        const handleVisibilityChange = () => {
          if (document.visibilityState === 'visible') {
            // Reset loading and error states before fetching
            setIsLoading(true);
            setError(null);
            // Add a small delay to ensure the app has fully resumed
            setTimeout(() => {
              getBusArrivals();
            }, 100);
          }
        };

        // Add a focus event listener specifically for iOS
        const handleFocus = () => {
          // Reset loading and error states before fetching
          setIsLoading(true);
          setError(null);
          // Add a small delay to ensure the app has fully resumed
          setTimeout(() => {
            getBusArrivals();
          }, 100);
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('focus', handleFocus);

        return () => {
          clearInterval(interval);
          clearInterval(timer);
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          window.removeEventListener('focus', handleFocus);
        };
      }, [stationConfigs]);

      useEffect(() => {
        feather.replace();
      });

      useEffect(() => {
        fetch('/stops.json')
          .then(response => response.json())
          .then(data => {
            setStopsData(data);
          })
          .catch(error => {
            console.error('Error fetching stops data:', error);
          });
      }, []);

      useEffect(() => {
        fetch('/services.json')
          .then(response => response.json())
          .then(data => {
            setServicesData(data);
          })
          .catch(error => {
            console.error('Error fetching services data:', error);
          });
      }, []);

      useEffect(() => {
        if (servicesData) {
          let mapping = {};
          Object.keys(servicesData).forEach(busNo => {
            servicesData[busNo].routes.forEach(route => {
              route.forEach(stationId => {
                if (!mapping[stationId]) {
                  mapping[stationId] = new Set();
                }
                mapping[stationId].add(busNo);
              });
            });
          });

          // Convert sets to arrays
          let mappingArrays = {};
          Object.keys(mapping).forEach(stationId => {
            mappingArrays[stationId] = Array.from(mapping[stationId]);
          });
          setStationToBusNumbers(mappingArrays);
        }
      }, [servicesData]);

      useEffect(() => {
        if (isQRCodeModalOpen && exportURL) {
          const qrcodeContainer = document.getElementById('qrcode');
          qrcodeContainer.innerHTML = '';
          new QRCode(qrcodeContainer, {
            text: exportURL,
            width: 200,
            height: 200,
          });
          feather.replace();
        }
      }, [isQRCodeModalOpen, exportURL]);

      useEffect(() => {
        const hash = window.location.hash;
        if (hash.startsWith('#import=')) {
          const compressedData = hash.substring(8); // remove '#import='
          try {
            const jsonString = LZString.decompressFromEncodedURIComponent(compressedData);
            const importedData = JSON.parse(jsonString);

            if (confirm('Do you want to import settings from this QR code? This will overwrite your current settings.')) {
              if (importedData.stationConfigs) {
                setStationConfigs(importedData.stationConfigs);
              }
              if (importedData.theme) {
                setTheme(importedData.theme);
              }
              // Clear the import from the URL hash
              window.location.hash = '';
            }
          } catch (error) {
            console.error('Error importing settings:', error);
            alert('Failed to import settings. The data may be corrupted.');
          }
        }
      }, []);

      async function handleNotify(bus) {
        const permission = await requestNotificationPermission();
        if (permission === 'granted') {
          scheduleNotification(bus);
        } else {
          showToast('Notifications are blocked. Please enable them in your browser settings.', 'error');
        }
      }

      async function requestNotificationPermission() {
        if (Notification.permission === 'granted') {
          return 'granted';
        }
        if (Notification.permission === 'denied') {
          return 'denied';
        }
        return await Notification.requestPermission();
      }

      function scheduleNotification(bus) {
        const remainingTimeMs = bus.arrivalTimestamp - Date.now();
        const notificationTime = bus.arrivalTimestamp - 60000; // Notify 60 seconds before arrival

        if (remainingTimeMs <= 0) {
          showToast('Bus is arriving now!', 'info');
        } else if (remainingTimeMs <= 60000) {
          showToast('Bus is arriving in less than 60 seconds!', 'info');
        } else {
          sendBusArrivalPreferences({
            msg: `Bus ${bus.busNo} is arriving around ${new Date(notificationTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}!`,
            time: notificationTime
          });
        }
      }

      async function sendBusArrivalPreferences({ msg, time }) {
        try {
          const subscription = await getPushSubscription(window.swReg);
          const response = await fetch('https://push.keva.dev/bus-arrival-notify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ subscription, msg, time })
          });
          
          if (!response.ok) {
            throw new Error('Failed to update bus arrival preferences');
          }
          
          showToast('Notification scheduled!', 'success');
        } catch (error) {
          console.error('Error updating bus arrival preferences:', error);
          showToast('Failed to update bus arrival preferences.', 'error');
        }
      }

      function showToast(message, type) {
        const toastContainer = document.getElementById('toast-container');

        const toast = document.createElement('div');
        toast.className = `alert alert-${type}`;
        toast.innerHTML = `
          <div class="flex items-center">
            <span>${message}</span>
          </div>
        `;

        toastContainer.appendChild(toast);

        setTimeout(() => {
          toast.remove();
        }, 3000);
      }

      function fetchRainForecast() {
        setIsRainLoading(true);
        setRainError(null);

        const latitude = 1.2896567808191362;
        const longitude = 103.82687802988048;

        const nowDate = new Date();

        fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=precipitation_probability&timezone=Asia%2FSingapore`)
          .then(response => response.json())
          .then(data => {
            const hourlyTimes = data.hourly.time;
            const precipitationProb = data.hourly.precipitation_probability;

            const nextTwoHours = [];

            for (let i = 0; i < hourlyTimes.length; i++) {
              const forecastTime = new Date(hourlyTimes[i]);
              const diffInMs = forecastTime - nowDate;
              const diffInHours = diffInMs / (1000 * 60 * 60);

              if (diffInHours > 0 && diffInHours <= 2) {
                nextTwoHours.push({
                  time: forecastTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                  precipitationProbability: precipitationProb[i]
                });
              }

              if (nextTwoHours.length >= 2) break;
            }

            if (nextTwoHours.length === 0) {
              setRainForecast({ expected: false });
            } else {
              const rainExpected = nextTwoHours.some(hour => hour.precipitationProbability > 50);

              if (rainExpected) {
                const rainyHours = nextTwoHours.filter(hour => hour.precipitationProbability > 50);
                setRainForecast({
                  expected: true,
                  details: rainyHours.map(hour => `${hour.time} (${hour.precipitationProbability}% chance)`)
                });
              } else {
                setRainForecast({ expected: false });
              }
            }

            setIsRainLoading(false);
          })
          .catch(error => {
            console.error('Error fetching rain forecast:', error);
            setRainError('Error fetching rain forecast data.');
            setIsRainLoading(false);
          });
      }

      function handleExportSettings() {
        const dataToExport = {
          stationConfigs,
          theme,
        };

        const jsonString = JSON.stringify(dataToExport);
        const compressedData = LZString.compressToEncodedURIComponent(jsonString);

        const currentURL = window.location.origin + window.location.pathname;
        const urlWithImport = `${currentURL}#import=${compressedData}`;

        setExportURL(urlWithImport);
        setIsQRCodeModalOpen(true);
      }

      async function grantPermissionForNotification() {
        try {
          const subscription = await getPushSubscription(window.swReg);
          if (!subscription) {
            throw new Error('Failed to get push subscription');
          }
          // Send the subscription to the server
          const response = await fetch('https://push.keva.dev/subscribe', {
            method: 'POST',
            body: JSON.stringify(subscription),
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error('Failed to send subscription to server');
          }
          showToast('Notification permission granted.', 'success');
          // Window reload
          
        } catch (error) {
          console.error('Error granting notification permission:', error);
          showToast('Failed to grant notification permission. Please try again.', 'error');
        }
      }

      useEffect(() => {
        // Listen for messages from service worker
        navigator.serviceWorker.addEventListener('message', event => {
          if (event.data.type === 'APP_UPDATED') {
            showToast('App has been updated to the latest version!', 'success');
            // Optionally, you can add a reload button
            const shouldReload = confirm('A new version is available. Would you like to reload now?');
            if (shouldReload) {
              window.location.reload();
            }
          }
        });
      }, []);

      function handleTabChange(newTab) {
        const tabOrder = ['home', 'settings', 'notifications', 'info'];
        const currentIndex = tabOrder.indexOf(activeTab);
        const newIndex = tabOrder.indexOf(newTab);
        
        setPreviousTab(activeTab);
        setSlideDirection(newIndex > currentIndex ? 'right' : 'left');
        setActiveTab(newTab);
      }

      useEffect(() => {
        // Reset scroll position when switching tabs
        const tabPage = document.querySelector('.tab-page.active');
        if (tabPage) {
          tabPage.scrollTop = 0;
        }
        
        // Force a reflow to ensure proper height calculation
        if (activeTab === 'home') {
          requestAnimationFrame(() => {
            const tabPage = document.querySelector('.tab-page.active');
            if (tabPage) {
              tabPage.style.display = 'none';
              tabPage.offsetHeight; // Force reflow
              tabPage.style.display = '';
            }
          });
        }
      }, [activeTab]);

      return html`
        <div class="page-container">
          <!-- Home Tab -->
          <div 
            class=${`tab-page ${
              activeTab === 'home' ? 'active' : ''
            } ${
              previousTab === 'home' ? 'previous' : ''
            } ${
              slideDirection && activeTab !== 'home' ? `slide-${slideDirection === 'right' ? 'left' : 'right'}` : ''
            }`}
          >
            <h1 class="text-center text-2xl font-bold mb-3 flex justify-between items-center">
              <div class="flex items-center">
                <i data-feather="heart" class="mr-2 w-6 h-6"></i>
                SG Bus Arrival
              </div>
              <button 
                class="btn btn-ghost btn-circle" 
                onClick=${() => {
                  setIsLoading(true);
                  getBusArrivals();
                  fetchRainForecast();
                }}
                disabled=${isLoading}
              >
                <i data-feather="refresh-cw" class=${isLoading ? 'animate-spin' : ''} />
              </button>
            </h1>
            
            ${isOffline && html`
              <div class="alert alert-warning mb-4">
                You are currently offline. Some features may not be available.
              </div>
            `}
            
            <!-- Weather Alert -->
            <div class="mb-2">
              ${isRainLoading ? html`
                <div class="alert flex items-center">
                  <span class="loading loading-spinner loading-sm mr-2"></span>
                  <span>Loading weather forecast...</span>
                </div>
              ` : rainError ? html`
                <p class="text-error">${rainError}</p>
              ` : rainForecast.expected ? html`
                <div class="alert alert-warning flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  <span>Rain is expected at ${rainForecast.details.join(' and ')}.</span>
                </div>
              ` : html`
                <div class="alert flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                  </svg>
                  <span>No rain expected in the next 2 hours.</span>
                </div>
              `}
            </div>

            <!-- Bus Arrivals -->
            ${isLoading ? html`
              <div class="spinner">
                <i data-feather="loader" class="animate-spin w-8 h-8"></i>
              </div>
            ` : stationConfigs.map(({ stationId }) => html`
              <div key=${stationId}>
                <h2 class="mt-4 mb-2 station-title font-semibold flex items-center">
                  <i data-feather="map-pin" class="mr-2 w-5 h-5"></i>${getStationDisplayName(stationId)}
                </h2>
                <div id="bus-arrival-times-${stationId}" class="mb-4">
                  ${busArrivals[stationId] && busArrivals[stationId].length > 0 ? html`
                    <div class="grid grid-cols-1 gap-4">
                      ${busArrivals[stationId].map(bus => {
                        const remainingTimeMs = bus.arrivalTimestamp - currentTime;
                        const totalSeconds = Math.floor(remainingTimeMs / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        
                        // Calculate progress percentage (assuming 15 minutes max wait time)
                        const progressPercent = Math.max(0, Math.min(100, (1 - (remainingTimeMs / (15 * 60 * 1000))) * 100));
                        
                        // Determine time status and color
                        let timeStatus;
                        const statusColor = 'text-info';
                        if (remainingTimeMs <= 30_000) {
                          timeStatus = 'Arriving';
                        } else if (minutes < 3) {
                          timeStatus = 'Very Soon';
                        } else {
                          timeStatus = `${minutes} min`;
                        }

                        const busRouteName = servicesData[bus.busNo]?.name || '';
                        const truncatedRouteName = busRouteName.length > 30 ? busRouteName.slice(0, 30) + '...' : busRouteName;

                        return html`
                          <div class="relative overflow-hidden rounded-lg bg-base-200">
                            <div class="absolute bottom-0 left-0 h-1 bg-base-content/20" style="width: ${progressPercent}%"></div>
                            
                            <div class="flex items-center p-4">
                              <!-- Bus Number Circle - using base-content for better contrast -->
                              <div class="flex-shrink-0">
                                <div class="w-16 h-16 rounded-full bg-base-content/10 flex items-center justify-center">
                                  <span class="text-xl font-bold text-base-content">${bus.busNo}</span>
                                </div>
                              </div>

                              <!-- Middle Content -->
                              <div class="flex-grow ml-4">
                                <div class="text-sm opacity-70">${truncatedRouteName}</div>
                                <div class="flex items-center mt-1">
                                  <i data-feather="clock" class="w-4 h-4 mr-1"></i>
                                  <span class="text-base-content text-lg font-semibold">
                                    ${timeStatus}
                                  </span>
                                  ${remainingTimeMs > 0 && minutes < 3 ? html`
                                    <span class="ml-1 text-sm opacity-70">${seconds}s</span>
                                  ` : ''}
                                </div>
                              </div>

                              <!-- Right Actions -->
                              <div class="flex-shrink-0">
                                <button 
                                  class="btn btn-circle btn-sm btn-ghost"
                                  onClick=${() => handleNotify(bus)}
                                  title="Set notification"
                                >
                                  <i data-feather="bell" class="w-4 h-4"></i>
                                </button>
                              </div>
                            </div>
                          </div>
                        `;
                      })}
                    </div>
                  ` : html`
                    <div class="text-center py-8">
                      <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-base-200 mb-4">
                        <i data-feather="clock" class="w-8 h-8 opacity-50"></i>
                      </div>
                      <p class="text-lg">No buses found for this stop</p>
                      <p class="text-sm opacity-70">Check back later or try another stop</p>
                    </div>
                  `}
                </div>
              </div>
            `)}
          </div>

          <!-- Settings Tab -->
          <div 
            class=${`tab-page ${
              activeTab === 'settings' ? 'active' : ''
            } ${
              previousTab === 'settings' ? 'previous' : ''
            } ${
              slideDirection && activeTab !== 'settings' ? `slide-${slideDirection === 'right' ? 'left' : 'right'}` : ''
            }`}
          >
            <h2 class="text-2xl font-bold mb-4">Settings</h2>
            <div class="config-panel">
              <!-- Add Export Settings Button -->
              <div class="mb-6">
                <h5 class="font-bold mb-2 flex items-center">
                  <i data-feather="share-2" class="mr-2 w-5 h-5"></i> Data Sync
                </h5>
                <button 
                  class="btn gap-2"
                  onClick=${handleExportSettings}
                >
                  <i data-feather="share" class="w-5 h-5"></i>
                  Export Settings
                </button>
              </div>

              <!-- Theme Toggle Section -->
              <div class="mb-6">
                <h5 class="font-bold mb-2 flex items-center">
                  <i data-feather="sun" class="mr-2 w-5 h-5"></i> Theme
                </h5>
                <button 
                  class="btn gap-2"
                  onClick=${toggleTheme}
                >
                  <i data-feather=${theme === 'light' ? 'moon' : 'sun'} class="w-5 h-5"></i>
                  ${theme === 'light' ? 'Switch to Dark Mode' : 'Switch to Light Mode'}
                </button>
              </div>

              <h5 class="font-bold mb-2 flex items-center">
                <i data-feather="map-pin" class="mr-2 w-5 h-5"></i> Bus Stations
              </h5>
              <form onSubmit=${addStation} class="flex mb-3 relative">
                <div class="relative w-full">
                  <input
                    type="text"
                    class="input input-bordered w-full"
                    placeholder="Enter Station ID or Name"
                    value=${newStationInput}
                    onInput=${e => handleStationInputChange(e.target.value)}
                    onFocus=${handleStationInputFocus}
                    onBlur=${handleStationInputBlur}
                  />
                  ${stationSuggestions.length > 0 && html`
                    <div class="autocomplete-suggestions">
                      ${stationSuggestions.map(suggestion => html`
                        <div
                          class="autocomplete-suggestion"
                          onMouseDown=${() => handleStationSelect(suggestion)}
                        >
                          ${suggestion.displayName}
                        </div>
                      `)}
                    </div>
                  `}
                </div>
                <button type="submit" class="btn btn-square btn-ghost ml-2">
                  <i data-feather="plus" class="w-5 h-5"></i>
                </button>
              </form>
              ${stationConfigs.map(({ stationId, busNumbers }) => html`
                <div class="mb-3 border rounded p-2 border-base-300">
                  <div class="flex justify-between items-center">
                    <strong>${getStationDisplayName(stationId)}</strong>
                    <button class="ml-2" onClick=${() => removeStation(stationId)}>
                      <i data-feather="trash-2" class="w-5 h-5"></i>
                    </button>
                  </div>
                  <div class="mt-2 flex flex-wrap">
                    ${busNumbers.map(busNo => html`
                      <span class="badge badge-secondary mr-2 mb-2 flex items-center">
                        ${busNo}
                        <button class="ml-1 p-0" onClick=${() => removeBusNumber(stationId, busNo)}>
                          <i data-feather="x" class="w-4 h-4"></i>
                        </button>
                      </span>
                    `)}
                  </div>
                  <form onSubmit=${e => addBusNumber(e, stationId)} class="flex mt-2 relative">
                    <div class="relative w-full">
                      <input
                        type="text"
                        class="input input-bordered w-full"
                        placeholder="Add Bus Number"
                        value=${newBusNumberInputs[stationId] || ''}
                        onInput=${e => handleBusNumberInputChange(stationId, e.target.value)}
                        onFocus=${e => handleBusNumberInputChange(stationId, e.target.value)}
                        onBlur=${e => handleBusNumberBlur(e, stationId)}
                      />
                      ${busNumberSuggestions[stationId] && busNumberSuggestions[stationId].length > 0 && html`
                        <div class="autocomplete-suggestions">
                          ${busNumberSuggestions[stationId].map(busNo => html`
                            <div
                              class="autocomplete-suggestion"
                              onMouseDown=${() => handleBusNumberSelect(stationId, busNo)}
                            >
                              ${busNo} - ${servicesData[busNo]?.name || ''}
                            </div>
                          `)}
                        </div>
                      `}
                    </div>
                    <button type="submit" class="ml-2 btn btn-square btn-ghost">
                      <i data-feather="plus" class="w-6 h-6"></i>
                    </button>
                  </form>
                </div>
              `)}
            </div>
          </div>

          <!-- Info Tab -->
          <div 
            class=${`tab-page ${
              activeTab === 'info' ? 'active' : ''
            } ${
              previousTab === 'info' ? 'previous' : ''
            } ${
              slideDirection && activeTab !== 'info' ? `slide-${slideDirection === 'right' ? 'left' : 'right'}` : ''
            }`}
          >
            <h2 class="text-2xl font-bold mb-4">About</h2>
            <div class="content">
              <p class="mb-2">
                SG Bus Arrival is a real-time bus tracking application tailored for commuters in Singapore. Unlike general platforms like Google Maps, this app allows you to pin specific bus stop locations near your home or workplace.
              </p>
              <p class="mb-2">
                By pinning your frequently used bus stops, you can quickly access the app during your daily routine to see the exact time you need to start walking from your home or workplace. This provides a more convenient and streamlined experience, ensuring you never miss your bus.
              </p>
              <p>
                This app utilizes data from <a href="https://busrouter.sg" class="underline" target="_blank">busrouter.sg</a> and weather information from <a href="https://open-meteo.com" class="underline" target="_blank">Open-Meteo</a>.
              </p>
            </div>
          </div>

          <!-- Notifications Tab -->
          <div 
            class=${`tab-page ${
              activeTab === 'notifications' ? 'active' : ''
            } ${
              previousTab === 'notifications' ? 'previous' : ''
            } ${
              slideDirection && activeTab !== 'notifications' ? `slide-${slideDirection === 'right' ? 'left' : 'right'}` : ''
            }`}
          >
            <h2 class="text-2xl font-bold mb-4">Notifications</h2>
            <button class="btn" onClick=${grantPermissionForNotification}>
              Enable Notifications
            </button>
          </div>

          <!-- Bottom Navigation -->
          <nav class="bottom-nav">
            <a 
              class=${`bottom-nav-item ${activeTab === 'home' ? 'active' : ''}`}
              onClick=${() => handleTabChange('home')}
            >
              <i data-feather="home" class="w-6 h-6 mb-1"></i>
              <span>Home</span>
            </a>
            <a 
              class=${`bottom-nav-item ${activeTab === 'settings' ? 'active' : ''}`}
              onClick=${() => handleTabChange('settings')}
            >
              <i data-feather="settings" class="w-6 h-6 mb-1"></i>
              <span>Settings</span>
            </a>
            <a 
              class=${`bottom-nav-item ${activeTab === 'notifications' ? 'active' : ''}`}
              onClick=${() => handleTabChange('notifications')}
            >
              <i data-feather="bell" class="w-6 h-6 mb-1"></i>
              <span>Alerts</span>
            </a>
            <a 
              class=${`bottom-nav-item ${activeTab === 'info' ? 'active' : ''}`}
              onClick=${() => handleTabChange('info')}
            >
              <i data-feather="info" class="w-6 h-6 mb-1"></i>
              <span>About</span>
            </a>
          </nav>

          <!-- QR Code Modal -->
          ${isQRCodeModalOpen && html`
            <div class="modal modal-open">
              <div class="modal-box relative">
                <button class="btn btn-sm btn-circle absolute right-2 top-2 p-0 bg-transparent border-none" onClick=${() => setIsQRCodeModalOpen(false)}>
                  <i data-feather="x" class="w-4 h-4"></i>
                </button>
                <h3 class="font-bold text-lg mb-4 flex items-center">
                  <i data-feather="share-2" class="mr-2 w-5 h-5"></i> Export Settings
                </h3>
                <div id="qrcode" class="flex justify-center"></div>
                <p class="mt-4 text-sm text-center">Scan this QR code with another device to import settings.</p>
                <div class="mt-2">
                  <div class="flex">
                    <input type="text" id="export-url-input" class="input input-bordered w-full" value="${exportURL}" readonly />
                    <button class="btn btn-square btn-ghost ml-2" onClick=${() => {
                      navigator.clipboard.writeText(exportURL).then(() => {
                        showToast('URL copied to clipboard!', 'success');
                      }, () => {
                        showToast('Failed to copy URL.', 'error');
                      });
                    }}>
                      <i data-feather="copy" class="w-5 h-5"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          `}
        </div>
      `;
    }

    render(html`<${App} />`, document.getElementById('app'));
  </script>
</body>
</html>
