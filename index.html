<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SG Bus Arrival</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1D232A" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <link rel="icon" href="/bus.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
  <script src="https://unpkg.com/feather-icons"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@intelight/geolib@2.0.22/dist/geolib.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <style>
    .config-toggle {
      cursor: pointer;
    }
    .refresh-btn {
      cursor: pointer;
      font-size: 1.5em;
    }
    .spinner {
      font-size: 2em;
      margin: 20px auto;
      display: flex;
      justify-content: center;
    }
    .station-title {
      font-size: 1.2em;
    }
    .card-custom {
      background-color: var(--card-bg-color);
    }
    .autocomplete-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      background-color: var(--card-bg-color);
      border: 1px solid var(--border-color);
      max-height: 150px;
      overflow-y: auto;
      width: 100%;
      z-index: 10;
    }
    .autocomplete-suggestion {
      padding: 8px;
      cursor: pointer;
    }
    .autocomplete-suggestion:hover {
      background-color: var(--hover-bg-color);
    }
    /* Remove input border on focus and blur */
    .input:focus,
    .input:active {
      outline: none;
      box-shadow: none;
      border-color: transparent;
    }
    /* Remove input border */
    .input {
      border-color: transparent;
    }
  </style>
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  <link rel="preload" href="/stops.json" as="fetch" crossorigin>
  <link rel="preload" href="/services.json" as="fetch" crossorigin>
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
</head>
<body class="bg-base-100 min-h-screen flex flex-col">
  <div id="toast-container" class="toast toast-top toast-center"></div>

  <div id="app" class="flex-grow"></div>

  <script src="https://unpkg.com/preact@latest/dist/preact.min.js"></script>
  <script src="https://unpkg.com/preact@latest/hooks/dist/hooks.umd.js"></script>
  <script src="https://unpkg.com/htm@latest/dist/htm.umd.js"></script>


  <!-- Add this script before your main script -->
  <script>
    // Check for service worker and Push API support
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(function(swReg) {
          console.log('Service Worker is registered', swReg);
          window.swReg = swReg;
        })
        .catch(function(error) {
          console.error('Service Worker Error', error);
        });
    } else {
      console.log('Push messaging is not supported');
    }

    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function getPushSubscription(swReg) {
      try {
        // Fetch the public VAPID key from the server
        const response = await fetch('https://push.keva.dev/vapidPublicKey');
        const data = await response.json();
        const publicVapidKey = data.publicKey;
        
        // Request notification permission from the user
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
          console.log('Permission not granted for Notification, it is: ' + permission);
          throw new Error('Notification permission not granted');
        }
        
        // Subscribe to push notifications
        const subscription = await swReg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(publicVapidKey)
        });

        console.log('Push Subscription:', JSON.stringify(subscription));
        return subscription;
      } catch (error) {
        console.error('Error in initializePush:', error);
      }
    }
  </script>

  <script>
    const { h, render } = preact;
    const { useState, useEffect, useRef } = preactHooks;
    const html = htm.bind(h);

    function App() {
      const [isOffline, setIsOffline] = useState(!navigator.onLine);
      const [stationConfigs, setStationConfigs] = useState(() => {
        const savedConfigs = localStorage.getItem('stationConfigs');
        return savedConfigs ? JSON.parse(savedConfigs) : [
          { stationId: '10389', busNumbers: ['121', '122'] },
          { stationId: '10161', busNumbers: ['121', '122'] },
        ];
      });
      const [busArrivals, setBusArrivals] = useState({});
      const [error, setError] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [currentTime, setCurrentTime] = useState(Date.now());

      const [theme, setTheme] = useState(() => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) return savedTheme;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      });

      const [newStationInput, setNewStationInput] = useState('');
      const [newBusNumberInputs, setNewBusNumberInputs] = useState({});
      const [isConfigModalOpen, setIsConfigModalOpen] = useState(false);
      
      const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);

      const [rainForecast, setRainForecast] = useState(null);
      const [isRainLoading, setIsRainLoading] = useState(true);
      const [rainError, setRainError] = useState(null);

      const [stopsData, setStopsData] = useState({});
      const [stationSuggestions, setStationSuggestions] = useState([]);
      const [selectedStationId, setSelectedStationId] = useState(null);

      const [servicesData, setServicesData] = useState({});
      const [busNumberSuggestions, setBusNumberSuggestions] = useState({});
      const [stationToBusNumbers, setStationToBusNumbers] = useState({});

      const [isQRCodeModalOpen, setIsQRCodeModalOpen] = useState(false);
      const [exportURL, setExportURL] = useState('');

      const [userLocation, setUserLocation] = useState(null);
      const [locationRequested, setLocationRequested] = useState(false);

      function toggleConfigModal() {
        setIsConfigModalOpen(!isConfigModalOpen);
      }
      
      function toggleInfoModal() {
        setIsInfoModalOpen(!isInfoModalOpen);
      }

      function addStation(e) {
        e.preventDefault();
        const stationId = selectedStationId || newStationInput.trim();
        if (stationId && !stationConfigs.find(s => s.stationId === stationId)) {
          const updatedConfigs = [...stationConfigs, { stationId: stationId, busNumbers: [] }];
          setStationConfigs(updatedConfigs);
          setNewStationInput('');
          setSelectedStationId(null);
          setStationSuggestions([]);
        }
      }

      function removeStation(stationId) {
        const updatedConfigs = stationConfigs.filter(s => s.stationId !== stationId);
        setStationConfigs(updatedConfigs);
        setNewBusNumberInputs(inputs => {
          const newInputs = { ...inputs };
          delete newInputs[stationId];
          return newInputs;
        });
        setBusNumberSuggestions(suggestions => {
          const newSuggestions = { ...suggestions };
          delete newSuggestions[stationId];
          return newSuggestions;
        });
      }

      function addBusNumber(e, stationId) {
        e.preventDefault();
        const newBusNumber = newBusNumberInputs[stationId];
        if (newBusNumber && newBusNumber.trim() !== '') {
          const updatedConfigs = stationConfigs.map(s => {
            if (s.stationId === stationId && !s.busNumbers.includes(newBusNumber)) {
              return { ...s, busNumbers: [...s.busNumbers, newBusNumber] };
            }
            return s;
          });
          setStationConfigs(updatedConfigs);
          setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: '' }));
          setBusNumberSuggestions(suggestions => ({ ...suggestions, [stationId]: [] }));
        }
      }

      function removeBusNumber(stationId, busNo) {
        const updatedConfigs = stationConfigs.map(s => {
          if (s.stationId === stationId) {
            return { ...s, busNumbers: s.busNumbers.filter(no => no !== busNo) };
          }
          return s;
        });
        setStationConfigs(updatedConfigs);
      }

      function handleBusNumberInputChange(stationId, value) {
        setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: value }));
        if (stationToBusNumbers[stationId]) {
          const suggestions = stationToBusNumbers[stationId]
            .filter(busNo => busNo.includes(value))
            .slice(0, 10);
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: suggestions }));
        } else {
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
        }
      }

      function handleBusNumberSelect(stationId, busNo) {
        setNewBusNumberInputs(inputs => ({ ...inputs, [stationId]: busNo }));
        setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
      }

      function handleBusNumberBlur(e, stationId) {
        // Hide suggestions after a short delay to allow clicks to register
        setTimeout(() => {
          setBusNumberSuggestions(suggestionsObj => ({ ...suggestionsObj, [stationId]: [] }));
        }, 100);
      }

      function handleStationInputChange(value) {
        setNewStationInput(value);
        setSelectedStationId(null);

        if (value.length >= 2 && stopsData) {
          const suggestions = Object.keys(stopsData).map(stationId => {
            const stop = stopsData[stationId];
            return {
              stationId: stationId,
              name: stop[2],
              road: stop[3],
              displayName: `${stop[2]} (${stop[3]}) [${stationId}]`,
            };
          }).filter(stop => {
            const searchValue = value.toLowerCase();
            return stop.name.toLowerCase().includes(searchValue) || stop.stationId.includes(value);
          }).slice(0, 10);

          setStationSuggestions(suggestions);
        } else if (value.length === 0 && userLocation) {
          computeNearestStations(userLocation.latitude, userLocation.longitude);
        } else {
          setStationSuggestions([]);
        }
      }

      function handleStationSelect(suggestion) {
        setNewStationInput(suggestion.displayName);
        setSelectedStationId(suggestion.stationId);
        setStationSuggestions([]);
      }

      function handleStationInputFocus() {
        if (!locationRequested) {
          setLocationRequested(true);
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              position => {
                setUserLocation({
                  latitude: position.coords.latitude,
                  longitude: position.coords.longitude
                });
                computeNearestStations(position.coords.latitude, position.coords.longitude);
              },
              error => {
                console.error('Error getting location:', error);
                // Optionally, show a message or proceed without location
              },
              { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
          } else {
            console.error('Geolocation is not supported by this browser.');
            // Optionally, show a message or proceed without location
          }
        } else if (userLocation) {
          computeNearestStations(userLocation.latitude, userLocation.longitude);
        }
      }

      function handleStationInputBlur() {
        // Hide suggestions after a short delay to allow selection
        setTimeout(() => {
          setStationSuggestions([]);
        }, 100);
      }

      function computeNearestStations(latitude, longitude) {
        if (!stopsData) return;
        const stations = Object.keys(stopsData).map(stationId => {
          const stop = stopsData[stationId];
          const stopLat = stop[0];
          const stopLon = stop[1];
          const distance = geolib.getDistance(
            { latitude, longitude },
            { latitude: stopLat, longitude: stopLon }
          );
          return {
            stationId: stationId,
            name: stop[2],
            road: stop[3],
            displayName: `${stop[2]} (${stop[3]}) [${stationId}]`,
            distance: distance
          };
        });
        stations.sort((a, b) => a.distance - b.distance);
        const nearestStations = stations.slice(0, 5);
        setStationSuggestions(nearestStations);
      }

      function haversineDistance(lat1, lon1, lat2, lon2) {
        function toRad(x) {
          return x * Math.PI / 180;
        }

        const R = 6371; // Earth's radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const lat1Rad = toRad(lat1);
        const lat2Rad = toRad(lat2);

        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1Rad) * Math.cos(lat2Rad);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const d = R * c;
        return d; // distance in km
      }

      function getStationDisplayName(stationId) {
        if (stopsData && stopsData[stationId]) {
          const stop = stopsData[stationId];
          return `${stop[2]} (${stop[3]})`;
        }
        return 'Station ' + stationId;
      }

      function getBusArrivals() {
        // Change timeout to 5 seconds
        const fetchTimeout = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Fetch timeout')), 5000);
        });

        setIsLoading(true);
        let fetchPromises = stationConfigs.map(({ stationId, busNumbers }) => {
          return Promise.race([
            fetch(`https://arrivelah2.busrouter.sg/?id=${stationId}`),
            fetchTimeout
          ])
            .then(response => response.json())
            .then(data => {
              const buses = data.services;
              const targetBuses = buses.filter(bus => busNumbers.includes(bus.no));

              let arrivalTimes = [];

              targetBuses.forEach(bus => {
                ['next', 'subsequent', 'next2', 'next3'].forEach(key => {
                  if (bus[key] && bus[key].duration_ms !== null && bus[key].duration_ms >= 0) {
                    arrivalTimes.push({
                      busNo: bus.no,
                      arrivalTimestamp: Date.now() + bus[key].duration_ms,
                      stationId: stationId,
                      key: key
                    });
                  }
                });
              });

              // Remove duplicates
              arrivalTimes = arrivalTimes.filter((value, index, self) =>
                index === self.findIndex((t) => (
                  t.busNo === value.busNo && t.arrivalTimestamp === value.arrivalTimestamp
                ))
              );

              arrivalTimes.sort((a, b) => a.arrivalTimestamp - b.arrivalTimestamp);

              const soonestBuses = arrivalTimes.slice(0, 3);

              return { stationId: stationId, arrivals: soonestBuses };
            })
            .catch(error => {
              console.error(`Error fetching bus data for station ${stationId}:`, error);
              setError(`Error fetching bus data for station ${stationId}`);
              return { stationId: stationId, arrivals: [] };
            });
        });

        Promise.all(fetchPromises)
          .then(results => {
            let newBusArrivals = {};
            results.forEach(result => {
              newBusArrivals[result.stationId] = result.arrivals;
            });
            setBusArrivals(newBusArrivals);
          })
          .catch(error => {
            console.error('Error fetching bus arrivals:', error);
            setError('Failed to fetch bus arrivals');
            showToast('Failed to fetch bus arrivals. Retrying...', 'error');
            // Auto retry after 1 second
            setTimeout(() => {
              getBusArrivals();
            }, 1000);
          })
          .finally(() => {
            setIsLoading(false);
          });
      }

      function toggleTheme() {
        const newTheme = theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
        document.querySelector('html').setAttribute('data-theme', newTheme);

        // Update theme colors
        if (newTheme === 'light') {
          document.documentElement.style.setProperty('--card-bg-color', '#ffffff');
          document.documentElement.style.setProperty('--border-color', '#e5e7eb');
          document.documentElement.style.setProperty('--hover-bg-color', '#f3f4f6');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#ffffff');
          }
        } else {
          document.documentElement.style.setProperty('--card-bg-color', '#1f2937');
          document.documentElement.style.setProperty('--border-color', '#374151');
          document.documentElement.style.setProperty('--hover-bg-color', '#4b5563');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1D232A');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#1D232A');
          }
        }
      }

      useEffect(() => {
        function handleOnline() {
          setIsOffline(false);
          showToast('You are back online.', 'success');
        }

        function handleOffline() {
          setIsOffline(true);
          showToast('You are offline. Some features may not be available.', 'warning');
        }

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      useEffect(() => {
        localStorage.setItem('stationConfigs', JSON.stringify(stationConfigs));
      }, [stationConfigs]);

      useEffect(() => {
        document.querySelector('html').setAttribute('data-theme', theme);
        if (theme === 'light') {
          document.documentElement.style.setProperty('--card-bg-color', '#ffffff');
          document.documentElement.style.setProperty('--border-color', '#e5e7eb');
          document.documentElement.style.setProperty('--hover-bg-color', '#f3f4f6');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#ffffff');
          }
        } else {
          document.documentElement.style.setProperty('--card-bg-color', '#1f2937');
          document.documentElement.style.setProperty('--border-color', '#374151');
          document.documentElement.style.setProperty('--hover-bg-color', '#4b5563');
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1D232A');
          if ('setAppBadgeBackgroundColor' in navigator) {
            navigator.setAppBadgeBackgroundColor('#1D232A');
          }
        }
      }, [theme]);

      useEffect(() => {
        getBusArrivals();

        const interval = setInterval(getBusArrivals, 30000);

        const timer = setInterval(() => {
          setCurrentTime(Date.now());
        }, 1000);

        fetchRainForecast();

        const handleVisibilityChange = () => {
          if (document.visibilityState === 'visible') {
            // Reset loading and error states before fetching
            setIsLoading(true);
            setError(null);
            // Add a small delay to ensure the app has fully resumed
            setTimeout(() => {
              getBusArrivals();
            }, 100);
          }
        };

        // Add a focus event listener specifically for iOS
        const handleFocus = () => {
          // Reset loading and error states before fetching
          setIsLoading(true);
          setError(null);
          // Add a small delay to ensure the app has fully resumed
          setTimeout(() => {
            getBusArrivals();
          }, 100);
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('focus', handleFocus);

        return () => {
          clearInterval(interval);
          clearInterval(timer);
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          window.removeEventListener('focus', handleFocus);
        };
      }, [stationConfigs]);

      useEffect(() => {
        feather.replace();
      });

      useEffect(() => {
        fetch('/stops.json')
          .then(response => response.json())
          .then(data => {
            setStopsData(data);
          })
          .catch(error => {
            console.error('Error fetching stops data:', error);
          });
      }, []);

      useEffect(() => {
        fetch('/services.json')
          .then(response => response.json())
          .then(data => {
            setServicesData(data);
          })
          .catch(error => {
            console.error('Error fetching services data:', error);
          });
      }, []);

      useEffect(() => {
        if (servicesData) {
          let mapping = {};
          Object.keys(servicesData).forEach(busNo => {
            servicesData[busNo].routes.forEach(route => {
              route.forEach(stationId => {
                if (!mapping[stationId]) {
                  mapping[stationId] = new Set();
                }
                mapping[stationId].add(busNo);
              });
            });
          });

          // Convert sets to arrays
          let mappingArrays = {};
          Object.keys(mapping).forEach(stationId => {
            mappingArrays[stationId] = Array.from(mapping[stationId]);
          });
          setStationToBusNumbers(mappingArrays);
        }
      }, [servicesData]);

      useEffect(() => {
        if (isQRCodeModalOpen && exportURL) {
          const qrcodeContainer = document.getElementById('qrcode');
          qrcodeContainer.innerHTML = '';
          new QRCode(qrcodeContainer, {
            text: exportURL,
            width: 200,
            height: 200,
          });
          feather.replace();
        }
      }, [isQRCodeModalOpen, exportURL]);

      useEffect(() => {
        const hash = window.location.hash;
        if (hash.startsWith('#import=')) {
          const compressedData = hash.substring(8); // remove '#import='
          try {
            const jsonString = LZString.decompressFromEncodedURIComponent(compressedData);
            const importedData = JSON.parse(jsonString);

            if (confirm('Do you want to import settings from this QR code? This will overwrite your current settings.')) {
              if (importedData.stationConfigs) {
                setStationConfigs(importedData.stationConfigs);
              }
              if (importedData.theme) {
                setTheme(importedData.theme);
              }
              // Clear the import from the URL hash
              window.location.hash = '';
            }
          } catch (error) {
            console.error('Error importing settings:', error);
            alert('Failed to import settings. The data may be corrupted.');
          }
        }
      }, []);

      async function handleNotify(bus) {
        const permission = await requestNotificationPermission();
        if (permission === 'granted') {
          scheduleNotification(bus);
        } else {
          showToast('Notifications are blocked. Please enable them in your browser settings.', 'error');
        }
      }

      async function requestNotificationPermission() {
        if (Notification.permission === 'granted') {
          return 'granted';
        }
        if (Notification.permission === 'denied') {
          return 'denied';
        }
        return await Notification.requestPermission();
      }

      function scheduleNotification(bus) {
        const remainingTimeMs = bus.arrivalTimestamp - Date.now();
        const notificationTime = bus.arrivalTimestamp - 60000; // Notify 60 seconds before arrival

        if (remainingTimeMs <= 0) {
          showToast('Bus is arriving now!', 'info');
        } else if (remainingTimeMs <= 60000) {
          showToast('Bus is arriving in less than 60 seconds!', 'info');
        } else {
          sendBusArrivalPreferences({
            msg: `Bus ${bus.busNo} is arriving around ${new Date(notificationTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}!`,
            time: notificationTime
          });
        }
      }

      async function sendBusArrivalPreferences({ msg, time }) {
        try {
          const subscription = await getPushSubscription(window.swReg);
          const response = await fetch('https://push.keva.dev/bus-arrival-notify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ subscription, msg, time })
          });
          
          if (!response.ok) {
            throw new Error('Failed to update bus arrival preferences');
          }
          
          showToast('Notification scheduled!', 'success');
        } catch (error) {
          console.error('Error updating bus arrival preferences:', error);
          showToast('Failed to update bus arrival preferences.', 'error');
        }
      }

      function showToast(message, type) {
        const toastContainer = document.getElementById('toast-container');

        const toast = document.createElement('div');
        toast.className = `alert alert-${type}`;
        toast.innerHTML = `
          <div class="flex items-center">
            <span>${message}</span>
          </div>
        `;

        toastContainer.appendChild(toast);

        setTimeout(() => {
          toast.remove();
        }, 3000);
      }

      function fetchRainForecast() {
        setIsRainLoading(true);
        setRainError(null);

        const latitude = 1.2896567808191362;
        const longitude = 103.82687802988048;

        const nowDate = new Date();

        fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=precipitation_probability&timezone=Asia%2FSingapore`)
          .then(response => response.json())
          .then(data => {
            const hourlyTimes = data.hourly.time;
            const precipitationProb = data.hourly.precipitation_probability;

            const nextTwoHours = [];

            for (let i = 0; i < hourlyTimes.length; i++) {
              const forecastTime = new Date(hourlyTimes[i]);
              const diffInMs = forecastTime - nowDate;
              const diffInHours = diffInMs / (1000 * 60 * 60);

              if (diffInHours > 0 && diffInHours <= 2) {
                nextTwoHours.push({
                  time: forecastTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                  precipitationProbability: precipitationProb[i]
                });
              }

              if (nextTwoHours.length >= 2) break;
            }

            if (nextTwoHours.length === 0) {
              setRainForecast({ expected: false });
            } else {
              const rainExpected = nextTwoHours.some(hour => hour.precipitationProbability > 50);

              if (rainExpected) {
                const rainyHours = nextTwoHours.filter(hour => hour.precipitationProbability > 50);
                setRainForecast({
                  expected: true,
                  details: rainyHours.map(hour => `${hour.time} (${hour.precipitationProbability}% chance)`)
                });
              } else {
                setRainForecast({ expected: false });
              }
            }

            setIsRainLoading(false);
          })
          .catch(error => {
            console.error('Error fetching rain forecast:', error);
            setRainError('Error fetching rain forecast data.');
            setIsRainLoading(false);
          });
      }

      function handleExportSettings() {
        const dataToExport = {
          stationConfigs,
          theme,
        };

        const jsonString = JSON.stringify(dataToExport);
        const compressedData = LZString.compressToEncodedURIComponent(jsonString);

        const currentURL = window.location.origin + window.location.pathname;
        const urlWithImport = `${currentURL}#import=${compressedData}`;

        setExportURL(urlWithImport);
        setIsQRCodeModalOpen(true);
      }

      async function grantPermissionForNotification() {
        try {
          const subscription = await getPushSubscription(window.swReg);
          if (!subscription) {
            throw new Error('Failed to get push subscription');
          }
          // Send the subscription to the server
          const response = await fetch('https://push.keva.dev/subscribe', {
            method: 'POST',
            body: JSON.stringify(subscription),
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error('Failed to send subscription to server');
          }
          showToast('Notification permission granted.', 'success');
          // Window reload
          
        } catch (error) {
          console.error('Error granting notification permission:', error);
          showToast('Failed to grant notification permission. Please try again.', 'error');
        }
      }

      useEffect(() => {
        // Listen for messages from service worker
        navigator.serviceWorker.addEventListener('message', event => {
          if (event.data.type === 'APP_UPDATED') {
            showToast('App has been updated to the latest version!', 'success');
            // Optionally, you can add a reload button
            const shouldReload = confirm('A new version is available. Would you like to reload now?');
            if (shouldReload) {
              window.location.reload();
            }
          }
        });
      }, []);

      return html`
        <div class="max-w-xl w-full mx-auto p-4 flex flex-col min-h-full">
          ${isOffline && html`
            <div class="alert alert-warning mb-4">
              You are currently offline. Some features may not be available.
            </div>
          `}
          <h1 class="text-center text-2xl font-bold mb-3 flex justify-center items-center">
            <i data-feather="heart" class="mr-2 w-6 h-6"></i>
            SG Bus Arrival
          </h1>
          ${error && html`<p class="text-error">${error}</p>`}

          <div class="mb-2">
            ${isRainLoading ? html`
            ` : rainError ? html`
              <p class="text-error">${rainError}</p>
            ` : rainForecast.expected ? html`
              <div class="alert alert-warning flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>Rain is expected at ${rainForecast.details.join(' and ')}.</span>
              </div>
            ` : html`
              <div class="alert flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
                <span>No rain expected in the next 2 hours.</span>
              </div>
            `}
          </div>

          <div class="flex justify-between items-center mb-3">
            <span class="refresh-btn" onClick=${getBusArrivals}>
              <i data-feather="refresh-cw" class="w-6 h-6"></i>
            </span>
            <div class="flex items-center">
              <button class="btn btn-square btn-ghost" onClick=${toggleTheme}>
                <i data-feather="${theme === 'light' ? 'moon' : 'sun'}" class="w-5 h-5"></i>
              </button>
              <button class="btn btn-square btn-ghost ml-2" onClick=${toggleConfigModal}>
                <i data-feather="settings" class="w-5 h-5"></i>
              </button>
              <button class="btn btn-square btn-ghost ml-2" onClick=${toggleInfoModal}>
                <i data-feather="info" class="w-5 h-5"></i>
              </button>
              <button class="btn btn-square btn-ghost ml-2" onClick=${grantPermissionForNotification}>
                <i data-feather="bell" class="w-5 h-5"></i>
              </button>
            </div>
          </div>

          ${isConfigModalOpen && html`
            <div class="modal modal-open">
              <div class="modal-box relative w-full h-full max-w-full mx-auto" style="margin-left: 5%; margin-right: 5%; max-width: 90%;">
                <button class="btn btn-circle absolute right-2 top-2 p-0 bg-transparent border-none" onClick=${toggleConfigModal}>
                  <i data-feather="x" class="w-6 h-6"></i>
                </button>
                <div class="flex justify-between items-center mb-2 mt-12">
                  <h3 class="font-bold text-lg flex items-center">
                    <i data-feather="settings" class="mr-2 w-5 h-5"></i> Configuration
                  </h3>
                  <button class="btn btn-square btn-ghost" onClick=${handleExportSettings}>
                    <i data-feather="share-2" class="w-5 h-5"></i>
                  </button>
                </div>
                <div class="config-panel overflow-y-auto h-full pb-16">
                  <h5 class="font-bold mb-2 flex items-center">
                    <i data-feather="map-pin" class="mr-2 w-5 h-5"></i> Bus Stations
                  </h5>
                  <form onSubmit=${addStation} class="flex mb-3 relative">
                    <div class="relative w-full">
                      <input
                        type="text"
                        class="input input-bordered w-full"
                        placeholder="Enter Station ID or Name"
                        value=${newStationInput}
                        onInput=${e => handleStationInputChange(e.target.value)}
                        onFocus=${handleStationInputFocus}
                        onBlur=${handleStationInputBlur}
                      />
                      ${stationSuggestions.length > 0 && html`
                        <div class="autocomplete-suggestions">
                          ${stationSuggestions.map(suggestion => html`
                            <div
                              class="autocomplete-suggestion"
                              onMouseDown=${() => handleStationSelect(suggestion)}
                            >
                              ${suggestion.displayName}
                            </div>
                          `)}
                        </div>
                      `}
                    </div>
                    <button type="submit" class="btn btn-square btn-ghost ml-2">
                      <i data-feather="plus" class="w-5 h-5"></i>
                    </button>
                  </form>
                  ${stationConfigs.map(({ stationId, busNumbers }) => html`
                    <div class="mb-3 border rounded p-2 border-base-300">
                      <div class="flex justify-between items-center">
                        <strong>${getStationDisplayName(stationId)}</strong>
                        <button class="ml-2" onClick=${() => removeStation(stationId)}>
                          <i data-feather="trash-2" class="w-5 h-5"></i>
                        </button>
                      </div>
                      <div class="mt-2 flex flex-wrap">
                        ${busNumbers.map(busNo => html`
                          <span class="badge badge-secondary mr-2 mb-2 flex items-center">
                            ${busNo}
                            <button class="ml-1 p-0" onClick=${() => removeBusNumber(stationId, busNo)}>
                              <i data-feather="x" class="w-4 h-4"></i>
                            </button>
                          </span>
                        `)}
                      </div>
                      <form onSubmit=${e => addBusNumber(e, stationId)} class="flex mt-2 relative">
                        <div class="relative w-full">
                          <input
                            type="text"
                            class="input input-bordered w-full"
                            placeholder="Add Bus Number"
                            value=${newBusNumberInputs[stationId] || ''}
                            onInput=${e => handleBusNumberInputChange(stationId, e.target.value)}
                            onFocus=${e => handleBusNumberInputChange(stationId, e.target.value)}
                            onBlur=${e => handleBusNumberBlur(e, stationId)}
                          />
                          ${busNumberSuggestions[stationId] && busNumberSuggestions[stationId].length > 0 && html`
                            <div class="autocomplete-suggestions">
                              ${busNumberSuggestions[stationId].map(busNo => html`
                                <div
                                  class="autocomplete-suggestion"
                                  onMouseDown=${() => handleBusNumberSelect(stationId, busNo)}
                                >
                                  ${busNo} - ${servicesData[busNo]?.name || ''}
                                </div>
                              `)}
                            </div>
                          `}
                        </div>
                        <button type="submit" class="ml-2 btn btn-square btn-ghost">
                          <i data-feather="plus" class="w-6 h-6"></i>
                        </button>
                      </form>
                    </div>
                  `)}
                </div>
              </div>
            </div>
          `}

          ${isQRCodeModalOpen && html`
            <div class="modal modal-open">
              <div class="modal-box relative">
                <button class="btn btn-sm btn-circle absolute right-2 top-2 p-0 bg-transparent border-none" onClick=${() => setIsQRCodeModalOpen(false)}>
                  <i data-feather="x" class="w-4 h-4"></i>
                </button>
                <h3 class="font-bold text-lg mb-4 flex items-center">
                  <i data-feather="share-2" class="mr-2 w-5 h-5"></i> Export Settings
                </h3>
                <div id="qrcode" class="flex justify-center"></div>
                <p class="mt-4 text-sm text-center">Scan this QR code with another device to import settings.</p>
                <div class="mt-2">
                  <div class="flex">
                    <input type="text" id="export-url-input" class="input input-bordered w-full" value="${exportURL}" readonly />
                    <button class="btn btn-square btn-ghost ml-2" onClick=${() => {
                      navigator.clipboard.writeText(exportURL).then(() => {
                        showToast('URL copied to clipboard!', 'success');
                      }, () => {
                        showToast('Failed to copy URL.', 'error');
                      });
                    }}>
                      <i data-feather="copy" class="w-5 h-5"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          `}

          ${isInfoModalOpen && html`
            <div class="modal modal-open">
              <div class="modal-box relative">
                <button class="btn btn-sm btn-circle absolute right-2 top-2 p-0 bg-transparent border-none" onClick=${toggleInfoModal}>
                  <i data-feather="x" class="w-4 h-4"></i>
                </button>
                <h3 class="font-bold text-lg mb-4 flex items-center">
                  <i data-feather="info" class="mr-2 w-5 h-5"></i> About SG Bus Arrival
                </h3>
                <div class="content">
                  <p class="mb-2">
                    SG Bus Arrival is a real-time bus tracking application tailored for commuters in Singapore. Unlike general platforms like Google Maps, this app allows you to pin specific bus stop locations near your home or workplace.
                  </p>
                  <p class="mb-2">
                    By pinning your frequently used bus stops, you can quickly access the app during your daily routine to see the exact time you need to start walking from your home or workplace. This provides a more convenient and streamlined experience, ensuring you never miss your bus.
                  </p>
                  <p>
                    This app utilizes data from <a href="https://busrouter.sg" class="underline" target="_blank">busrouter.sg</a> and weather information from <a href="https://open-meteo.com" class="underline" target="_blank">Open-Meteo</a>.
                  </p>
                </div>
              </div>
            </div>
          `}

          ${isLoading ? html`
            <div class="spinner">
              <i data-feather="loader" class="animate-spin w-8 h-8"></i>
            </div>
          ` : stationConfigs.map(({ stationId }) => html`
            <div key=${stationId}>
              <h2 class="mt-4 mb-2 station-title font-semibold flex items-center">
                <i data-feather="map-pin" class="mr-2 w-5 h-5"></i>${getStationDisplayName(stationId)}
              </h2>
              <div id="bus-arrival-times-${stationId}">
                ${busArrivals[stationId] && busArrivals[stationId].length > 0 ? busArrivals[stationId].map(bus => {
                  const remainingTimeMs = bus.arrivalTimestamp - currentTime;
                  let timeString;
                  if (remainingTimeMs > 0) {
                    const totalSeconds = Math.floor(remainingTimeMs / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                  } else {
                    timeString = 'Arrived';
                  }

                  const busRouteName = servicesData[bus.busNo]?.name || '';
                  const truncatedRouteName = busRouteName.length > 30 ? busRouteName.slice(0, 30) + '...' : busRouteName;

                  return html`
                    <div class="card mb-2 card-custom border border-base-300">
                      <div class="card-body p-3">
                        <div class="flex justify-between items-center">
                          <div>
                            <h5 class="card-title mb-0">${bus.busNo}</h5>
                            ${truncatedRouteName && html`<p class="text-sm">${truncatedRouteName}</p>`}
                          </div>
                          <div class="flex items-center">
                            <span class="text-sm mr-2">${timeString}</span>
                            <button class="btn btn-ghost btn-sm p-0" onClick=${() => handleNotify(bus)}>
                              <i data-feather="bell" class="w-5 h-5"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  `;
                }) : html`<p>No buses found for station ${stationId}</p>`}
              </div>
            </div>
          `)}

          <footer class="text-center mt-4 text-sm text-gray-500 dark:text-gray-400">
            SG Bus Arrival by <a href="https://tuhuynh.com" class="underline">Tu Huynh</a>, bus data by <a href="https://busrouter.sg" class="underline">busrouter.sg</a>
          </footer>
        </div>
      `;
    }

    render(html`<${App} />`, document.getElementById('app'));
  </script>
</body>
</html>
